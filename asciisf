#! /usr/bin/perl
use warnings;
use strict;
use IPC::Open2;
use Parse::RecDescent;
use Data::Dumper;
use feature 'switch';

sub hex2str {
	my $hex = shift;
	
	if (length($hex) % 2) {
		$hex = '0' . $hex;
	}
	# reverse to make it little-endian.
	scalar reverse pack( 'H' . length($hex), $hex);
}

sub bytes2long {
	# If there are fewer than 4 bytes, assume they're the low-order ones, so
	# pad with NUL bytes at the end.
	my $str = shift . "\0"x4;
	unpack "L", $str;
}

my $grammar = q{
call: name '(' bytes ')'
    { \%item }

name: /\\w+/
    { $item[1] }

bytes: bytesprime(s?)
    { join('', @{$item[1]}) }

bytesprime:
    string
        { $item[1] }
    | hex
        { $item[1] }
string:
    "'" name  "'"
        { $item{name} }
    | '"' name'"'
        { $item{name} }

hex: /[0-9a-fA-F]+/
    { ::hex2str($item[1]) }
  };

my $parser = new Parse::RecDescent($grammar);

my $pid = open2(my $in, my $out, "./sysfuck");

while (my $line = <STDIN>) {
	next if $line =~ /^\s*$/;
	my %parsed = %{ $parser->call($line) or warn("Syntax error\n"), next };
	my $name = $parsed{name};
	my $bytes = $parsed{bytes};
	
	print $out $name, chr(0), chr(length $bytes), $bytes;

	given ($name) {
		when ("memwrite") { next; }
		when ("memread") {
			read $in, my $str, bytes2long(substr($bytes, 4, 4));
			print "$str\n";
		}
		default {
			read $in, my $str, 4;
			my $num = bytes2long($str);
			printf("%d (0x%x)\n", $num, $num);
		}
	}
}
